       A 6 8 K    M A I N T E N A N C E    H I S T O R Y


Version 2.71.F3 (David Ellsworth, July 11, 2000)

	Fixed a bug introduced by my modifications that prevented
	branches from being optimized in Global XRef mode.

Version 2.71.F2 (David Ellsworth, January 22, 1998)

	Made A68k properly differentiate between PC-relative and
	absolute references to external symbols. Allowed branches
	to reference external labels in Global XRef (-g parameter)
	mode.

Version 2.71.F1 (David Ellsworth, January 7, 1998)

	Made changes so that combinations of EQU, XREF, and XDEF
	directives work better together. These changes were made in
	order for Fargo II library linking to be easier to do.

	The F1 stands for Fargo patchlevel 1.

Version 2.71 (Charlie Gibbs, April 16, 1991)

	The following bugs in version 2.62 have been corrected:

	      - Enforcer checks were being generated if command-line
		parameters that took a numeric value had no value or
		the value was invalid.  CalcValue was attempting to
		look up a label in the symbol table, which having not
		been allocated yet was causing a null pointer to be
		dereferenced.  (Patrick Quaid)

	The following enhancements have been added:

	      - Function prototyping has been added.  All function
		prototypes are in a new include file, protos.h, which
		is included by A68kdef.h.  Prototyping can be disabled
		(for compilers which do not support it) by defining
		the symbol __NOPROTO; in this case old-style function
		declarations are generated instead.


Version 2.70 (Charlie Gibbs, February 25, 1991)

	The following bugs in version 2.62 have been corrected:

	      - The definition of tempstr in WriteSymTab (24 bytes)
		was being overrun in some cases, causing A68k to hang.
		Its length has been increased to MAXLINE.
		(Paul Gittings, John Antonishek)

	      - If A7 was in a list of registers in the source operand
		of a MOVEM instruction, all registers would be moved
		(i.e. the mask was set to 0xFFFF).  (Risto Kaivola)

	      - Octal or binary values that set bit 31 were being
		flagged as overflow errors.  (Harvey Taylor)

	      - ORGs were unnecessarily restricted when the -s flag was
		specified.  Everything should be absolute when S-records
		are generated, and any absolute ORG should be allowed.

	The following enhancements have been added:

	      - A new INCBIN directive has been added.  It takes a
		single operand, a file name whose contents are
		included as is at the current position in the
		object code file.  (Julian Gold, Colin Fox)

	      - The opcode TTL is now accepted as a synonym for TITLE.

	      - The file mode in the creat() call in xopen() has been
		changed from 1 to 0644; this provides a reasonable file
		mode when compiled on a Unix system.  (Paul Gittings)

	      - A new command-line keyword (-g) has been added.  It
		causes all undefined symbols to be treated as XREF.
		(Paul Gittings, Steve Hawtin (who provided the code))

	      - All initialized fields in opcodes.c have been made global
		for compatibilty with more compilers.  (Steve Hawtin)

	      - The register list in a MOVEM instruction can now be an
		immediate operand which specifies the actual mask bits.
		(Paul Gittings, who provided the code)

	      - The default value for the -q option has been changed
		from 10 to 100.


Version 2.62 (Charlie Gibbs, March 19, 1990)

	The following enhancements have been added:

	      - A new command-line keyword (-m) has been added.
		It must be immediately followed by a number which
		specifies the offset from the beginning of a small
		data section to the base register specified in the
		NEAR directive (defaulting to A4).  If this parameter
		is omitted, the offset defaults to 32768 bytes.  This
		parameter is meaningful only if the NEAR directive
		is used.  (Colin Fox)


Version 2.61 (Charlie Gibbs, January 11, 1990)

	The following bugs in version 2.6 have been corrected:

	      - ORG and RORG at the beginning of the program were
		being processed incorrectly.  (Jukka Jarvinen)

	      - A branch instruction to its own label, e.g.
			lab	bra	lab
		would cause phase errors; the instruction was
		being shortened on pass 2 but not on pass 1.
		(Kevin Hoare)

	The following enhancements have been added:

	      - Labels may begin with '@' if the next character
		is not numeric (to avoid confusion with octal
		constants).  (Colin Fox)

	      - Write errors now cause A68k to terminate gracefully
		with an appropriate error message.


Version 2.6 (Charlie Gibbs, November 2, 1989)

	The following bugs in version 2.5 have been corrected:

	      - If a space is left between a file keyword and the file name
		(e.g. A68k -l foo.lst foo.asm) the source file was scratched.
		(E. Lenz)

	      - All code using post-increment addressing in references to
		toupper() has been reworked to avoid post-increment.  Such
		code does not work correctly if toupper() is a macro.
		(John K. Antonishek)

	      - The spelling of the include files A68kdef.h and A68kglb.h
		has been made correct as to case.  This simplifies porting
		to case-sensitive file systems.  (John K. Antonishek)

	      - If comments immediately follow the operands of an XDEF,
		XREF, or PUBLIC statement with no intervening white space
		(as in any of the following statements), A68k would hang:
			XDEF	foo;comments
			XREF	bar;comments
			PUBLIC	blah;comments
		(Bruce Dawson)

	      - Numeric values (any radix) which do not fit into 32 bits
		were not being flagged.  (E. Lenz)

	      - DC statements with no operands were not being flagged.
		(E. Lenz)

	      - The -f option was suggesting short branches where the
		displacement would be zero, which is illegal.  (E. Lenz)

	      - Branches outside the current section had the offset
		set to zero.  (Matt Dillon, who provided a fix)

	      - ADDI, ANDI, CMPI, EORI, ORI, and SUBI instructions whose
		source operand was not immediate were not being flagged.
		(E. Lenz)

	      - Unary NOT of a byte or word immediate operand whose value
		was negative was being flagged as a size error.
		(John Aycock)

	      - All forward branches were rejected when the NEAR
		directive was active.  (Colin Fox)

	The following enhancements have been added:

	      - Single-byte immediate operands (e.g. MOVE.B #-1,(a0))
		are now padded with a high-order byte of zero, rather
		than being sign-extended.  (E. Lenz)

	      - The message "Error in operand format." has been changed
		to "Addressing mode not allowed here." in places where
		the latter message is more appropriate.

	      - If the -q option species a value of zero (or no value
		is given, defaulting to zero), all console output will
		be suppressed except for error messages, if any.
		(Matt Dillon)

	      - The 128-byte restriction on constant length no longer
		applies to the entire code generated by a single DCB
		statement; statements such as
			DCB.L	64,0
		can now be handled.  (Colin Fox)

	      - Forward branches are now optimized.  The occasional
		instruction may be missed due to ripple effects, but
		this shouldn't happen frequently.  The -f switch
		will flag any such instructions.

	      - The -d switch can now be followed by an optional
		prefix string (with or without a leading !) which
		specifies which symbols should or should not be
		included in the symbol table dump.  (Lionel Hummel)


Version 2.5 (Charlie Gibbs, June 18, 1989)

	The following bugs in version 2.42 have been corrected:

	      - Upon normal termination, A68k occasionally crashed in
		quit_cleanup by trying to free the relocation table twice.
		(Jeff Lydiatt and D. McClelland, who worked out a fix)

	      - MEMF_CHIP and MEMF_FAST bits were being set in the
		hunk length, rather than in the hunk type.  (Richard Man)

	      - BCHG.L, BCLR.L, BSET.L, and BTST.L were causing
		phase errors.  The test to ignore the .L specification
		(added in version 1.21) was being skipped in pass 1
		by an optimization added in version 2.4.  (David Hankins)

	      - PC-relative offset to a label was calculated as two bytes
		too great for MOVEM instructions.  (Tony Parkhurst)

	The following enhancements have been added:

	      - If the length code on an opcode is not .B, .W, .L, .S,
		or omitted, it will be flagged as an error.

	      - JMP.S and JSR.S are flagged as errors.  (Jim Butterfield)

	      - Operands of the form (xxxx).W and (xxxx).L are now
		supported.  This enables absolute short or absolute
		long addressing to be explicitly specified.

	      - All optimization can be disabled by the new -n switch.
		(David Hankins)

	      - The NEAR directive can now take a single operand, which
		can be any address register (or equated symbol) except
		A7.  If omitted, the register defaults to A4.

	      - Instructions of the form BTST Dn,#nn are no longer
		flagged.  This obscure variant is nonetheless legal.


Version 2.42 (Charlie Gibbs, January 10, 1989)

	The following bugs in version 2.41 have been corrected:

	      - Small code/data conversion was sometimes taking place
		when no NEAR directive was active.  (Jeff Lydiatt)


Version 2.41 (Charlie Gibbs, January 6, 1989)

	The following bugs in version 2.4 have been corrected:

	      - The second operand of LINK instructions was
		being erroneously flagged.

	      - If a macro was used before it was defined, it
		was being expanded during pass 2 but not during
		pass 1, causing severe phase errors.  Attempts
		to use a macro before it is defined will now
		be flagged as invalid opcodes.  (Colin Fox)


Version 2.4 (Charlie Gibbs, January 4, 1989)

	The following bugs in version 2.31 have been corrected:

	      - If comments immediately followed the operands of
		a DC statement with no intervening white space,
		A68k would hang.  (Ulf Nordquist)

	      - In the following command:
			a68k -w 15000 myprog.asm
		the space between the -w and 15000 would cause A68k
		to look for a source file called "15000", and to think
		that the object file is to be called "myprog.asm".
		When it can't find "15000" it would display an error
		message and scratch "myprog.asm".  (Jeff Lydiatt)

	      - If an INCLUDE file that is skipped on pass 2 contains
		a macro call, subsequent uses of \@ (macro sequence
		number are subsequently flagged.  The macro counter
		must be bumped along with the line number when
		skipping an INCLUDE.  (Colin Fox, Harvey Taylor)

	The following enhancements have been added:

	      - ORG and RORG are now fully implemented.

	      - The SET symbols A68k, a68K, and a68k are defined in the
		same way as A68K, making it effectively case-insensitive.
		(Colin Fox)

	      - MOVEM and REG now accept equated register names (EQUR)
		in register lists.  (Bruce Dawson)

	      - INCLUDE files will now be skipped on pass 2 even when
		a listing file is requested, if the listing has been
		turned off by a NOLIST directive before the INCLUDE,
		and is not turned on until after the end of the
		INCLUDE file has been reached.  (Colin Fox)

	      - A new switch (-f) causes forward branches (Bcc, BRA, BSR)
		that could be coded as short branches (Bcc.S etc.) to be
		flagged.  This flag is not considered to be an error.

	      - A limited small code / small data model has been provided.
		It is activated by a NEAR directive in the source code, and
		is de-activated by a FAR directive.  External variables
		must be declared at the beginning of the program, which
		must consist of only two sections (CODE and DATA or BSS).
		All forward data references are assumed to be PC-relative
		if in the CODE section, A4-relative if in the DATA/BSS
		section, and absolute word if absolute values.  Any
		forward references which cannot be resolved to one of
		these three in pass 2 will be flagged as errors, as will
		any attempt to define more than two sections.  A4 is
		assumed to point to the start of the DATA/BSS section
		plus 32768 bytes, and must be loaded by a MOVE.L
		instruction using immediate mode unless this instruction
		is not enclosed within NEAR and FAR directives.

	      - Miscellaneous optimizations, for speed, including:
		Most of the object code generator in pass 1 is bypassed.
		If GetValue gets a single term it takes a short cut.
		IsOperator now uses a table look-up.
		Instructions now only searches that portion of the
		opcode table whose opcodes start with the same letter
		as the OpCode being searched for.


Version 2.31 (Charlie Gibbs, November 30, 1988)

	The following bugs in version 2.3 have been corrected:

	      - Even though a macro definition was being skipped
		by IFxx/ENDC, its ENDM directive was still being
		detected, causing spurious diagnostics.  (Harvey Taylor)

	      - NOP was not being recognized.  When moving all
		directives into the opcode table, NOL and NOLIST
		were placed after NOP, rather than before.  (Colin Fox)

	      - Symbols defined in the current module and declared
		as PUBLIC were not being written to the object code
		file when -d was specified.  (Colin Fox)

	      - Conversion of 0(An) to (An) (implemented in version
		1.2) was causing errors in the MOVEP instruction,
		which requires a displacement even if it is zero.
		This conversion is now disabled for MOVEP instructions.

	      -	User macros containing invalid opcodes caused A68k
		to get lost when returning to the outer source file.
		(Colin Fox)

	      - Large values of -w (over 6000 or so) would cause
		a visit from the Guru.  The work field in HashIt
		was overflowing and going negative.  Changing it
		to unsigned corrected the problem.  (Colin Fox)

	      - Although user macros are no longer displayed when
		-q is a negative number, the calling file's name
		was still being displayed at the end of the macro.


Version 2.3 (Charlie Gibbs, November 21, 1988)

	The following enhancements have been added:

	      - All file I/O has been rewritten to use level 1 I/O
		(open, creat, close, read, write, and lseek) instead
		of level 2 I/O.  A68k now does its own buffering and
		unbuffering to reduce system overhead and increase speed.
		(Bruce Dawson)

	      - All assembler directives have been incorporated into
		the opcode table.  Since the opcode search now looks
		up directives as well, speed is increased.

	      - Miscellaneous code optimization for additional speed.


Version 2.2 (Charlie Gibbs, November 4, 1988)

	The following bugs in version 2.1 have been corrected:

	      - Macro definitions within an INCLUDE file were
		disabling the test for skipping the file on pass 2.

	      - Errors encountered in an INCLUDE file on pass 1
		were not disabling the skip of the file on pass 2 -
		the pertinent error messages could not appear.

	      - XDEF information and optional symbol table dumps were
		not being written to the object code file for any
		hunks that did not contain relocatable code or data.
		(Colin Fox)

	The following enhancements have been added:

	      - If the -q option is specified as a negative value,
		user macros are no longer included in line number
		displays, reducing clutter.

	      - Some source code has been re-arranged to reduce size.


Version 2.1 (Charlie Gibbs, November 1, 1988)

	The following bugs in version 2.00 have been corrected:

	      - Macro definitions that span two chunks of memory
		were causing garbage and probably a crash when
		the macro was being expanded.  Pointers were not
		being handled properly when linking the two chunks.

	      - Statements such as EQU and SET were not being flagged
		as illegal forward references if referencing a label
		defined on the same line, e.g.
			LABEL	SET	LABEL+1

	      - The position within macros and INCLUDE files was
		sometimes out by one line when reported in error
		messages (and the new feature of the -q switch).

	The following enhancements have been added:

	      - If the -q option is specified as a negative value,
		line numbers will be displayed as positions within
		the current module (whose name is also displayed),
		rather than a total statement count.  (Bruce Dawson)

	      - INCLUDE files can be skipped on pass 2 even if they
		contain SET statements - the values of all symbols
		SET in the INCLUDE file are stored (as at the end
		of the file) in a separate table and are patched
		when the INCLUDE file is skipped.  (Bruce Dawson)


Version 2.00 (Charlie Gibbs, October 26, 1988)

	The following bugs in version 1.24 have been corrected:

	      - The last digit of the statement number display
		(lengthened in version 1.24) was not being erased
		before displaying error messages.

	      - A68k would go into a loop if a user macro was
		missing an ENDC directive.  This error is now
		flagged (see below).

	The following enhancements have been added:

	      - The highest statement number displayed at the end of
		each pass is now left on the screen.  This means that,
		at the end of pass 1, you can always see how many lines
		A68k will have to process in pass 2, giving an idea of
		how how much longer you have to wait.  (Colin Fox)

	      - The symbol table is now built using a hashing algorithm.
		This eliminates the slowdown that occurs in pass 1 as
		the symbol table grows, due to the old insertion process.
		(Bruce Dawson)

	      - If A68k terminates abnormally for any reason (such as
		insufficient memory) the object file is scratched
		(unless the -k option is set).  (Bruce Dawson)

	      - Any INCLUDE files which cannot be found are flagged
		as errors in pass 1, and the assembly is aborted
		at the end of pass 1.  (Bruce Dawson)

	      - Missing ENDC directives are flagged in macro expansions.
		Also, missing or unpaired ENDC directives in user macros
		are flagged.

	      - If an INCLUDE file doesn't generate any code and no
		listing file is required, it won't be read again in
		pass 2.  The statement numbers will be bumped to keep
		in proper alignment.  This can really speed up
		assemblies that INCLUDE lots of equates.  (Colin Fox)


Version 1.24 (Charlie Gibbs, October 11, 1988)

	The following bugs in version 1.23 have been corrected:

	      - MOVEA to a data register was not being flagged, even
		though all other invalid addressing modes were.

	      - Attempts to ORG out of the current hunk (including
		to an absolute address) were not being flagged.  (E. Lenz)

	      - If the size of the bottom of the primary heap (symbols
		and macro text) exceeded 32K, any further macro
		definitions would expand as endless garbage.  (Colin Fox)

	      - If the size of the bottom of the primary heap (symbols
		and macro text) exceeded 64K, any further external
		symbols (XDEF) would be flagged as relocatability
		errors upon each reference.  (Colin Fox)

	The following enhancements have been added:

	      - Where statement numbers are displayed as fixed-length
		fields, their maximum length has been increased
		from 4 digits to 5.  (Colin Fox)

	      - The PUBLIC directive has been implemented.
		As with the Aztec assembler, any labels defined as
		PUBLIC will be treated as XDEF if defined within
		the current module, and XREF otherwise.  (Jeff Lydiatt)


Version 1.23 (Charlie Gibbs, September 20, 1988)

	The following bugs in version 1.22 have been corrected:

	      - The test for a third operand was producing erroneous
		error messages on instructions whose second operand
		was in immediate mode.  The '#' was not being taken
		into account, since it is not copied to DestOp.


Version 1.22 (Charlie Gibbs, August 31, 1988)

	The following bugs in version 1.21 have been corrected:

	      - Expressions of the form R-A, where R is a relocatable
		term or expression and A is an absolute term or
		expression, were being flagged as relocation errors.
		This was due to a bug in the routine which should
		(but did not) flag expressions of the form A-R.
		(David Ashley)

	      - Instructions with three operands were not being
		flagged as errors.  This can be caused by an extra
		comma being typed in the instruction, as in:
			BTST #0,state+3,(a5)
		The second comma should not be present.  (David Ashley)

	The following enhancements have been added:

	      - Excess spacing has been removed from the listing file.
		These changes are similar to those already made to the
		console output (probably at about version 1.05).

	      - If the first statement in the source file is TTL or
		PAGE, an empty page is no longer produced at the
		start of the listing.


Version 1.21 (Charlie Gibbs, July 29, 1988)

	The following bugs in version 1.2 have been corrected:

	      - The instruction
			BTST.L	#8,D0
		had a long-word value generated for the bit number.
		This bug also applies to BSET, BCLR, and BCHG.
		The .L specification is now ignored.  (Ulf Nordquist)


Version 1.2 (Charlie Gibbs, July 19, 1988)

	The following bugs in version 1.12 have been corrected:

	      - A reference to the label of the current instruction
		was being converted to PC-relative on pass 2 but not
		on pass 1.  This was causing phase errors.  The label
		hasn't been added to the symbol table at the time the
		instruction is processed.  Conversion to PC-relative
		addressing will now not be attempted in this case,
		although references to * can and will be converted.

	      - All string-type DC statements, regardless of length,
		were being treated as DC.B.  For example, DC.L 'A'
		would generate only one byte of object code.
		(Gerald Hull)

	      - DC.W and DC.B statements were not being checked to
		ensure that their values would fit into a word or
		a byte respectively.

	      - If a comment line had white space preceding the
		asterisk, A68k would hang.  Actually, it was
		interpreting the asterisk as an opcode and trying
		to open a macro file called "*".  Since under
		AmigaDOS such a file is the console, A68k was
		actually waiting for console input.

	      - If an instruction with no operands (such as RTS
		or NOP) followed MOVE.L #rel,D0 where "rel" was
		a relocatable symbol, the RTS (etc.) would have
		its nonexistent operands flagged as invalid.

	      - SECTION names enclosed in quotes were not being
		handled correctly.

	      - Source modules that did not generate any code, data,
		or BSS areas, but only defined symbols, such as
			label	equ	4
				xdef	label
				end
		were generating incomplete object modules.

	The following enhancements have been added:

	      - Jeff's experimental hunk code (prefixing hunk names
		with a sequence number before adding to the symbol
		table) has been permanently incorporated.  It seems
		to work better with BLink on programs that have
		hunks continued farther on in the source code.
		(Jeff Lydiatt)

	      - The macro parameter \0, which is replaced by the
		size specification in the macro call (B, W, or L,
		defaulting to W) is now supported.  (Gerald Hull)

	      - Operands of the form 0(An) will be treated as (An).
		(Bruce Dawson)


Version 1.12 (Charlie Gibbs, May 25, 1988)

	The following bugs in version 1.11 have been corrected:

	      - If an instruction with no operands (e.g. RTS)
		followed a MOVE.L #label,D0 the RTS would be
		flagged with a relocatability error.  Src.Mode
		and Dest.Mode were not being cleared.  (Colin Fox)


Version 1.11 (Charlie Gibbs, April 6, 1988)

	The following bugs in version 1.10 have been corrected:

	      - A68k would go into a loop while processing the
		arguments of a macro call, if these arguments are
		followed by comments separated from the arguments
		by one or more tab characters, and the -t switch
		is specified on the command line.  All tests for
		blanks have been replaced by calls to isspace().

	      -	The operand alignment checks added in version 1.06
		were erroneously testing the following instructions:
			BCHG
			BCLR
			BSET
			BTST
			NBCD
			Scc
			TAS
		These instructions are now exempt from alignment checking.

	The following enhancements have been added:

	      - A listing file name can now be specified with the
		-x switch; it is no longer necessary to specify
		both the -l and -x switches to produce a cross-
		reference listing with a name other than the default.

	      - DS statements with more than one operand are
		flagged and ignored (in case they should be DC).

	      - A character string used as a numeric value is
		flagged and set to zero if it is more than four
		characters long.


Version 1.10 (Charlie Gibbs, March 20, 1988)

	The following bugs in version 1.07 have been corrected:

	      - BSS sections were not being written to the object
		code file except for a BSS section at the end of
		a program.  This is due to a bug in the code added
		in version 1.05 to overwrite null sections.

	      - If a source module contained a mixture of lengths
		(8, 16, or 32 bits) in external references (XREF)
		to the same label, all references were being treated
		as if they has the length of the first reference.

	The following enhancements have been added:

	      - DS operands that are either a forward references
		or relocatable are now flagged.

	      - Short branches (Bcc.S, including BRA and BSR) to
		the next instruction (i.e. a displacement of zero)
		are illegal - the processor takes the displacement
		from the next word.  Attempts to generate a short
		displacement of zero are now flagged.


Version 1.07 (Charlie Gibbs, March 11, 1988)

	The following bugs in version 1.06 have been corrected:

	      - Instructions that take no operands (such as RTS)
		were being flagged if they had comments that were
		not preceded by a semicolon.

	The following enhancements have been added:

	      - The following synonyms have been added:
			CSEG  for CODE (Aztec compatibility)
			DSEG  for DATA    "          "
			ENDIF for ENDC (Assempro compatibility)
			=     for EQU      "           "
			|     for !        "           "

	      - Strings and character values may be delimited by
		either apostrophes (') or quotation marks (").
		The character not used as a delimiter can be used
		within the string without doubling it.  For example,
			DC.B	"This is Charlie's assembler"
		produces the same code as
			DC.B	'This is Charlie''s assembler"

	      - The object code file will be scratched if any errors
		were found, unless the -k (keep) flag is set.
		(Bruce Dawson)

	      - The symbol .A68K is automatically defined at the
		beginning of each assembly as a SET symbol with an
		absolute value of 1.  This enables programs to check
		whether they're being assembled by this assembler.
		(Jeff Lydiatt)

	      - The symbol table insertion routine has been
		greatly speeded up.


Version 1.06 (Charlie Gibbs, March 6, 1988)

	The following bugs in version 1.05 have been corrected:

	      - Lines skipped by IFxx/ENDC were not being counted
		in the line number given in error messages.

	      - DATA and BSS sections may be unnamed, or have names
		the same as CODE sections.  Honest, I thought section
		names had to be unique even across types.

	      - CHIP and FAST options on the CODE, DATA, and BSS
		synonyms for the SECTION directive were not being
		handled correctly.

	      - XDEF records and symbol table records (if desired)
		were not being produced for symbols defined ahead
		of the first object-code producing instruction.

	The following enhancements have been added:

	      - The CNOP instruction can now force alignment
		relative to any boundary up to 128 bytes.
		The second operand must still be a power of 2.

	      - The -q switch has been added to change the frequency
		with which progress reports (current line number) are
		displayed on the console.  The default remains at
		every 10 lines (-q10).  If you specify -q (no interval)
		or -q0 the line number displays will be suppressed.
		This will make assemblies run slightly faster due to
		reduced console I/O.  (Bill Henning)

	      - The -t switch has been added to keep any tabs in the
		source file when producing the listing file, as well as
		generating tabs elsewhere whenever possible.  This
		speeds up assemblies and gives smaller listing files,
		but such listing files cannot be displayed on devices
		that do not assume a tab stop in every 8th position.
		(Bruce Dawson)

	      - Any single-operand instruction with two operands,
		and any no-operand instruction with any operands,
		will be flagged.

	      - Relocatable 8- or 16-bit immediate operands
		will be flagged.  They blow up BLink.

	      - Named local labels are now supported.  Their names
		are formed in the same way as normal labels, but are
		then preceded by a backslash.  Their scope is the
		same as normal local labels (nnn$).  (Colin Fox)

	      - An alignment error will be flagged in the following cases:
		    Odd displacement on a LINK instruction
		    Bcc or DBcc to an odd address
		    In any word or long-word instruction, any operand
		      using the following addressing modes:
			Address register indirect with displacement
			Address register indirect with index and displacement
			Absolute short
			Absolute long
			Program counter indirect with displacement
			Program counter indirect with index and displacement
		    LEA and PEA instructions are exempt from these tests.

	      - If a section is found to contain no data, A68k will
		back up to its beginning and overwrite it with the
		next section.  The result is that null sections
		will no longer appear in the object file.


Version 1.05 (Charlie Gibbs, October 30, 1987)

	The following bugs in version 1.04 have been corrected:

	      - If a section was continued later in the program, e.g.

			SECTION	prog,CODE
			  <code>
			SECTION	variables,BSS
			  <DS statements>
			SECTION	prog,CODE
			  <more code>

		bad relocation information was being generated for
		the continuation of the SECTION.  This bug was left
		over from version 1.03.

	The following enhancements have been added:

	      - All console output except for error messages is now
		sent to stderr - this enables stdout to be redirected,
		producing an error file.

	      - Console (stderr) output has been modified to require
		fewer lines on the screen.

	      - If an error occurs while expanding a macro or INCLUDE
		file, the position of the call in each outer file is
		given along with the position in the current (innermost)
		file.  Tracing continues until the outermost file (i.e.
		the original source file) is reached.


Version 1.04 (Charlie Gibbs, October 21, 1987)

	The following bugs in version 1.03 have been corrected:

	      - MOVE was being converted to MOVEQ regardless of
		operand size - this conversion is legal only
		for longword MOVEs.

	      - Modifications to version 1.03 caused bad relocatable
		entries to be generated.


Version 1.03 (Charlie Gibbs, October 14, 1987)

	The following bugs in version 1.02 have been corrected:

	      - The following situation was causing phase errors:

				xdef	label
				bra	label
				 .
			    <at least 128 bytes of object code>
				 .
			label:

		(The XDEF was fooling A68k into thinking that "label"
		was defined within 128 bytes of the BRA instruction
		on pass 1, although on pass 2 it knew better.

	      - If the first operand of an two-operand executable
		instruction contained a character term containing a
		left or right parenthesis, it would generate error
		messages and be incorrectly evaluated.

	      - Labels that don't begin in column 1 (denoted by a
		trailing colon) caused a Guru Meditation.

	      - Certain ADD and SUB instructions using PC-relative
		addressing may cause phase errors.  If the displacement
		is in the range 1 to 8 inclusive, the instruction was
		erroneously converted to ADDQ or SUBQ during pass 2.

	The following enhancements have been added:

	      - The -z option has been added to display the
		current source program line on stdout as it
		is read, optionally over a given range.
		This feature is provided for debugging purposes.

	      - Bcc, BSR, and DBcc to labels in other than the current
		section is now supported.  A 16-bit relocation entry
		will be generated for each such reference.

	      - PC relative mode will be generated for backward
		references to labels within the current CODE section
		if legal for the current instruction.  Forward
		references will not be converted, since there is
		no way of telling which section the label is in
		during pass 1.

	      - The cumulative sizes of all sections by type (i.e.
		CODE, DATA, and BSS) will be displayed at the end
		of the listing file and the console display.
		(Bruce Dawson)

	      - In the symbol table dump, section names will no
		longer be indicated just as SECTION, but rather
		as CODE, DATA, or BSS, depending on type.


Version 1.02 (Charlie Gibbs, September 9, 1987)

	The following bugs in version 1.01 have been corrected:

	      - Duplicate labels were not being flagged.

	      - XDEF symbols were not being dumped to the
		object code file when the -d option was set.

	The following enhancements have been added:

	      - A header file is now supported.  If the parameter
		-h<filespec> is included on the command line, the
		specified file will be included as if the source
		file's first line was " include <filespec>".
		The file specification may include a path name,
		although the include path names given by the
		-i parameter (if any) will also be searched.

	      - An equate file can now be produced.  If the parameter
		-e<filespec> is included on the command line, a file
		will be written containing EQU statements for any
		symbol whose value is absolute.  If -e is specified
		without <filespec>, the name of the file will be
		formed in the same way as the list file, except with
		an extension of ".equ".  (Bruce Dawson)

	The following changes have been made to existing logic:

	      - No symbol table dump will be produced unless the
		-x (cross-reference) switch is set.  Formerly a
		symbol table dump was always produced, with only
		the cross-reference portion optional.


Version 1.01 (Charlie Gibbs, August 20, 1987)

	The following bugs in version 1.00 have been corrected:

	      - Long-word constants and storage areas were being
		aligned on a double-word boundary.  The only place
		where double-word alignment is now forced is at a
		break between SECTIONs, since the length of an
		AmigaDOS hunk must be a multiple of 4 bytes.
		(CNOP 0,4 can still be used if double-word
		alignment is desired by the programmer.)

	      - If a label on an END statement or the first statement
		of a SECTION was named in an XDEF statement, it would
		not be written to the object code file.  The latter
		case includes both the label of a SECTION directive
		and the label of the first executable instruction in
		the absence of any SECTION directives (defaulting to
		an unnamed CODE section).  In the final case (default
		unnamed CODE section), references to XREF symbols
		in the first statement would also not be written
		to the object code file.

	      - If the last statement in the source file was not
		terminated with a newline character (premature EOF),
		it was being ignored altogether.

	      - A register list as the source operand of a MOVE
		instruction was not being flagged as an error.
		(MOVE to a register list was being flagged, however.)

	      - MOVE from USP was generating incorrect code.  Also,
		MOVE from SR or CCR to an address register was
		generating incorrect code rather than being flagged.


Version 1.00 (Charlie Gibbs, June 18, 1987) - initial release
